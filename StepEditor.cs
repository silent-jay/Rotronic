using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
// Requires DocumentFormat.OpenXml NuGet package (Open XML SDK)
using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Bibliography;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Spreadsheet;

namespace Rotronic
{
    public partial class StepEditor : Form
    {
        // Pseudocode / Plan (detailed):
        // 1. Add a private boolean field `_hasUnsavedChanges` to track edits. (already present)
        // 2. Detect and prevent entry into accuracy cells when the corresponding
        //    "pass/fail" checkbox column is unchecked.
        //    - Define canonical column detection for:
        //        temp pass/fail -> "temppassfail"
        //        temperature accuracy -> columns containing both "accuracy" and "temp" / "temperature"
        //        hum pass/fail -> "humppassfail" / "humpassfail"
        //        humidity accuracy -> columns containing both "accuracy" and "hum" / "humidity"
        //      (All checks should be case-insensitive; missing columns are handled gracefully.)
        // 3. Wire `CellValidating` to prevent input into accuracy columns when the pass/fail box is unchecked.
        //    - On validating: if editing an accuracy cell and the related pass/fail is false, clear the cell value.
        // 4. When a pass/fail checkbox cell changes (CellValueChanged), if it becomes unchecked,
        //    clear any existing values in the corresponding accuracy cells for that row.
        // 5. Keep marking `_hasUnsavedChanges = true` on mutations (already done in existing handlers).
        // 6. Implement small helper methods:
        //    - `FindColumnIndexByName(string)` - finds column index by name/header case-insensitive.
        //    - `FindTemperatureAccuracyColumnIndex()` / `FindHumidityAccuracyColumnIndex()` - best-effort detection.
        //    - `GetCellBoolValue(rowIndex, colIndex)` - robustly interprets cell value as bool.
        //    - `ClearTempFields(rowIndex)` / `ClearHumFields(rowIndex)` - set accuracy cells to empty.
        // 7. Ensure all operations are safe if columns are absent or rows are out of range.
        // 8. Keep UI unobtrusive: do not show message boxes for each auto-clear, just enforce the rule.
        //
        // This comment block serves as the step-by-step plan. The code below implements it.

        private bool _hasUnsavedChanges = false;

        public StepEditor()
        {
            InitializeComponent();

            // Wire FormClosing to check for unsaved changes
            this.FormClosing += StepEditor_FormClosing;


            // Wire DataGridView events to detect user edits
            // These assume `dataGridViewStep` exists (generated by the designer)
            dataGridViewStep.CellValueChanged += DataGridViewStep_Changed;
            dataGridViewStep.UserAddedRow += DataGridViewStep_Changed;
            dataGridViewStep.UserDeletedRow += DataGridViewStep_Changed;
            dataGridViewStep.RowsRemoved += DataGridViewStep_Changed;
            dataGridViewStep.CurrentCellDirtyStateChanged += DataGridViewStep_CurrentCellDirtyStateChanged;

            // New: validate cell entries to prevent invalid data entry for accuracy fields
            dataGridViewStep.CellValidating += DataGridViewStep_CellValidating;
        }

        private void StepEditor_FormClosing(object sender, FormClosingEventArgs e)
        {
            // If there are no unsaved changes, just allow close
            if (!_hasUnsavedChanges)
                return;

            // Ask the user whether to proceed without saving
            bool proceed = UnsavedChangesWarning();
            if (!proceed)
            {
                // User cancelled -> keep the form open
                e.Cancel = true;
            }
            // If proceed is true, allow closing (no need to set e.Cancel)
        }

        private bool UnsavedChangesWarning()
        {
            var message = "There are unsaved changes. Do you want to proceed without saving?";
            var caption = "Unsaved Changes";
            var result = MessageBox.Show(this, message, caption, MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);
            return result == DialogResult.OK;
        }

        // Event handlers to mark the form as having unsaved changes
        private void DataGridViewStep_Changed(object sender, EventArgs e)
        {
            _hasUnsavedChanges = true;

            // If this was a CellValueChanged event, check for pass/fail toggles and clear dependent fields
            if (e is DataGridViewCellEventArgs cellArgs)
            {
                int rowIndex = cellArgs.RowIndex;
                int colIndex = cellArgs.ColumnIndex;
                if (rowIndex < 0 || colIndex < 0)
                    return;

                var col = dataGridViewStep.Columns[colIndex];
                string colName = (col?.Name ?? col?.HeaderText ?? string.Empty).Trim();

                // When temp pass/fail is toggled and becomes unchecked, clear temperature accuracy
                if (string.Equals(colName, "temppassfail", StringComparison.OrdinalIgnoreCase))
                {
                    bool pass = GetCellBoolValue(rowIndex, colIndex);
                    if (!pass)
                    {
                        ClearTempFields(rowIndex);
                    }
                }

                // When hum pass/fail is toggled and becomes unchecked, clear humidity accuracy
                if (string.Equals(colName, "humppassfail", StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(colName, "humpassfail", StringComparison.OrdinalIgnoreCase))
                {
                    bool pass = GetCellBoolValue(rowIndex, colIndex);
                    if (!pass)
                    {
                        ClearHumFields(rowIndex);
                    }
                }
            }
        }

        private void DataGridViewStep_CurrentCellDirtyStateChanged(object sender, EventArgs e)
        {
            // If the current cell is dirty, commit the edit so CellValueChanged fires
            if (dataGridViewStep.IsCurrentCellDirty)
            {
                dataGridViewStep.CommitEdit(DataGridViewDataErrorContexts.Commit);
            }
            _hasUnsavedChanges = true;
        }

        // Validate cell edits: prevent entering values into accuracy fields when pass/fail is unchecked
        private void DataGridViewStep_CellValidating(object sender, DataGridViewCellValidatingEventArgs e)
        {
            if (e.RowIndex < 0 || e.ColumnIndex < 0)
                return;

            var col = dataGridViewStep.Columns[e.ColumnIndex];
            string colName = (col?.Name ?? col?.HeaderText ?? string.Empty).Trim();
            string combined = ((col?.Name ?? "") + "|" + (col?.HeaderText ?? "")).ToLowerInvariant();

            // Temperature accuracy protection: any column that contains "accuracy" and "temp"/"temperature"
            bool isTempAccuracy = combined.Contains("accuracy") && (combined.Contains("temp") || combined.Contains("temperature"));

            // Humidity accuracy protection: any column that contains "accuracy" and "hum"/"humidity"
            bool isHumAccuracy = combined.Contains("accuracy") && (combined.Contains("hum") || combined.Contains("humidity"));

            if (isTempAccuracy)
            {
                int tempPassCol = FindColumnIndexByName("temppassfail");
                if (tempPassCol >= 0)
                {
                    bool pass = GetCellBoolValue(e.RowIndex, tempPassCol);
                    if (!pass)
                    {
                        // Prevent entry by clearing the attempted value
                        dataGridViewStep.Rows[e.RowIndex].Cells[e.ColumnIndex].Value = null;
                        // Do not cancel navigation; simply enforce empty value
                        e.Cancel = false;
                        _hasUnsavedChanges = true;
                    }
                }
            }

            if (isHumAccuracy)
            {
                int humPassCol = FindColumnIndexByName("humppassfail");
                if (humPassCol < 0)
                    humPassCol = FindColumnIndexByName("humpassfail"); // support alternate name

                if (humPassCol >= 0)
                {
                    bool pass = GetCellBoolValue(e.RowIndex, humPassCol);
                    if (!pass)
                    {
                        dataGridViewStep.Rows[e.RowIndex].Cells[e.ColumnIndex].Value = null;
                        e.Cancel = false;
                        _hasUnsavedChanges = true;
                    }
                }
            }
        }

        private void newListToolStripMenuItem_Click(object sender, EventArgs e)
        {
            DataLossWarning();
        }
        private bool DataLossWarning()
        {
            {
            var message = "This will clear any unsaved changes. Proceed?";
            var caption = "Confirm";
            var result = MessageBox.Show(this, message, caption, MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);

                if (result != DialogResult.OK)
                    return false;
                ClearData();
                return true;
            }
        }
        private void ClearData()
        {

            // If the grid is bound to a DataSource, try to clear the underlying data safely.
            if (dataGridViewStep.DataSource != null)
            {
                // If DataSource is a DataTable
                if (dataGridViewStep.DataSource is DataTable dt)
                {
                    dt.Clear();
                }
                else if (dataGridViewStep.DataSource is BindingSource bs)
                {
                    // If the BindingSource wraps a DataTable, clear it; otherwise detach the BindingSource.
                    if (bs.DataSource is DataTable bsTable)
                    {
                        bsTable.Clear();
                    }
                    else
                    {
                        bs.DataSource = null;
                        dataGridViewStep.DataSource = null;
                    }
                }
                else
                {
                    // Fallback: unbind the grid
                    dataGridViewStep.DataSource = null;
                }

                // Ensure any remaining rows are removed for safety
                if (dataGridViewStep.Rows.Count > 0 && dataGridViewStep.DataSource == null)
                    dataGridViewStep.Rows.Clear();
            }
            else
            {
                // Unbound grid: clear rows
                dataGridViewStep.Rows.Clear();
            }

            // Clearing data is a change that is not saved
            _hasUnsavedChanges = true;
        }

        private void saveToolStripMenuItem_Click(object sender, EventArgs e)
        {
            // First perform data validation
            bool isValid = DataValidation();
            if (!isValid)
            {
                // Validation failed; do not proceed with save
                return;
            }
            // Determine application exe folder and ensure "Step Files" subfolder exists
            string exeFolder = Application.StartupPath; // safe for WinForms
            string stepFilesFolder = Path.Combine(exeFolder, "Step Files");
            try
            {
                if (!Directory.Exists(stepFilesFolder))
                    Directory.CreateDirectory(stepFilesFolder);
            }
            catch (Exception ex)
            {
                MessageBox.Show(this, "Unable to create folder for saving files: " + ex.Message, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            using (var dlg = new SaveFileDialog())
            {
                dlg.InitialDirectory = stepFilesFolder;
                dlg.Filter = "Excel Workbook|*.xlsx";
                dlg.DefaultExt = "xlsx";
                dlg.FileName = "Steps.xlsx";
                dlg.Title = "Save Steps as Excel Workbook";

                if (dlg.ShowDialog(this) != DialogResult.OK)
                    return;

                string filePath = dlg.FileName;
                try
                {
                    ExportDataGridViewToXlsx(dataGridViewStep, filePath);
                    // If we reach here, save succeeded -> clear unsaved flag
                    _hasUnsavedChanges = false;
                }
                catch (Exception ex)
                {
                    MessageBox.Show(this, "Failed to save file: " + ex.Message, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }

        private bool DataValidation()
        {

            /* Plan (detailed pseudocode):
             1. Change signature to return bool: true when validation passes (no errors), false when errors found.
             2. Keep existing validation logic intact.
             3. When errors are found:
                - Focus the first invalid cell if possible.
                - Show combined message box.
                - Return false.
             4. When no errors:
                - Clear lingering ErrorText values.
                - Return true.
             5. Ensure no other behavioral changes.
            */

            // Local helpers
            int FindColumnIndexContaining(params string[] tokens)
            {
                if (tokens == null || tokens.Length == 0)
                    return -1;

                for (int i = 0; i < dataGridViewStep.Columns.Count; i++)
                {
                    var c = dataGridViewStep.Columns[i];
                    string combined = ((c?.Name ?? "") + "|" + (c?.HeaderText ?? "")).ToLowerInvariant();
                    bool all = true;
                    foreach (var t in tokens)
                    {
                        if (string.IsNullOrWhiteSpace(t))
                            continue;
                        if (!combined.Contains(t.ToLowerInvariant().Trim()))
                        {
                            all = false;
                            break;
                        }
                    }
                    if (all)
                        return i;
                }
                return -1;
            }

            bool TryParseTwoDecimal(string raw, out double result)
            {
                result = 0;
                if (string.IsNullOrWhiteSpace(raw))
                    return false;

                string s = raw.Trim();
                // Allow comma as decimal separator by normalizing to dot
                s = s.Replace(',', '.');

                // Reject if there are multiple dots
                int dotCount = s.Count(ch => ch == '.');
                if (dotCount > 1)
                    return false;

                // Remove leading + sign
                if (s.StartsWith("+"))
                    s = s.Substring(1);

                // Use invariant culture for parsing after normalization
                if (!double.TryParse(s, System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out result))
                    return false;

                // Check decimal places by inspecting the normalized string (avoid floating rounding issues)
                int idx = s.IndexOf('.');
                if (idx < 0)
                {
                    // integer -> 0 decimals -> allowed
                    return true;
                }

                string frac = s.Substring(idx + 1);
                // If frac contains exponent part (e.g. "1.23e3"), split at 'e' or 'E'
                int eidx = frac.IndexOfAny(new char[] { 'e', 'E' });
                if (eidx >= 0)
                    frac = frac.Substring(0, eidx);

                // Disallow more than 2 decimal digits
                if (frac.Length > 2)
                    return false;

                return true;
            }

            string FormatTwoDecimal(double value)
            {
                // Use current culture formatting to present to the user, but ensure two decimals
                return value.ToString("F2", System.Globalization.CultureInfo.CurrentCulture);
            }

            // Identify columns (best-effort)
            int colStep = FindColumnIndexContaining("step");
            int colTempSet = FindColumnIndexContaining("temp", "set");
            int colHumSet = FindColumnIndexContaining("hum", "set");
            int colEvalTemp = FindColumnIndexContaining("eval", "temp");
            if (colEvalTemp < 0) colEvalTemp = FindColumnIndexContaining("evaluate", "temp");
            int colEvalHum = FindColumnIndexContaining("eval", "hum");
            if (colEvalHum < 0) colEvalHum = FindColumnIndexContaining("evaluate", "hum");

            // Accuracy columns (new behaviour)
            int colTempAccuracy = -1;
            int colHumAccuracy = -1;
            for (int i = 0; i < dataGridViewStep.Columns.Count; i++)
            {
                var c = dataGridViewStep.Columns[i];
                string combined = ((c?.Name ?? "") + "|" + (c?.HeaderText ?? "")).ToLowerInvariant();
                if (combined.Contains("accuracy") && (combined.Contains("temp") || combined.Contains("temperature")))
                    colTempAccuracy = i;
                if (combined.Contains("accuracy") && (combined.Contains("hum") || combined.Contains("humidity")))
                    colHumAccuracy = i;
            }

            var errors = new List<string>();
            DataGridViewCell firstInvalidCell = null;

            for (int rowIndex = 0; rowIndex < dataGridViewStep.Rows.Count; rowIndex++)
            {
                var row = dataGridViewStep.Rows[rowIndex];
                if (row.IsNewRow)
                    continue;

                // Clear any previous error texts on this row's cells (we'll set if needed)
                foreach (DataGridViewCell c in row.Cells)
                    c.ErrorText = string.Empty;

                // 1) Step column selected
                if (colStep >= 0)
                {
                    var stepCell = row.Cells[colStep];
                    var val = stepCell?.Value;
                    if (val == null || string.IsNullOrWhiteSpace(val.ToString()))
                    {
                        string msg = $"Row {rowIndex + 1}: Step not selected.";
                        errors.Add(msg);
                        if (firstInvalidCell == null) firstInvalidCell = stepCell;
                        if (stepCell != null) stepCell.ErrorText = "Select a step";
                    }
                }

                // 2) Temperature setpoint must be valid double with up to 2 decimals; format to 2 decimals
                if (colTempSet >= 0)
                {
                    var cell = row.Cells[colTempSet];
                    var raw = cell?.Value?.ToString() ?? string.Empty;
                    if (string.IsNullOrWhiteSpace(raw))
                    {
                        string msg = $"Row {rowIndex + 1}: Temperature set point is empty or invalid.";
                        errors.Add(msg);
                        if (firstInvalidCell == null) firstInvalidCell = cell;
                        if (cell != null) cell.ErrorText = "Enter temperature set point";
                    }
                    else
                    {
                        if (!TryParseTwoDecimal(raw, out double parsed))
                        {
                            string msg = $"Row {rowIndex + 1}: Temperature set point must be a number with at most 2 decimals.";
                            errors.Add(msg);
                            if (firstInvalidCell == null) firstInvalidCell = cell;
                            if (cell != null) cell.ErrorText = "Invalid format (max 2 decimals)";
                        }
                        else
                        {
                            // Normalize/formatted display to 2 decimals
                            try
                            {
                                cell.Value = FormatTwoDecimal(parsed);
                            }
                            catch { /* ignore formatting failure */ }
                        }
                    }
                }

                // 3) Humidity setpoint must be valid double with up to 2 decimals; format to 2 decimals
                if (colHumSet >= 0)
                {
                    var cell = row.Cells[colHumSet];
                    var raw = cell?.Value?.ToString() ?? string.Empty;
                    if (string.IsNullOrWhiteSpace(raw))
                    {
                        string msg = $"Row {rowIndex + 1}: Humidity set point is empty or invalid.";
                        errors.Add(msg);
                        if (firstInvalidCell == null) firstInvalidCell = cell;
                        if (cell != null) cell.ErrorText = "Enter humidity set point";
                    }
                    else
                    {
                        if (!TryParseTwoDecimal(raw, out double parsed))
                        {
                            string msg = $"Row {rowIndex + 1}: Humidity set point must be a number with at most 2 decimals.";
                            errors.Add(msg);
                            if (firstInvalidCell == null) firstInvalidCell = cell;
                            if (cell != null) cell.ErrorText = "Invalid format (max 2 decimals)";
                        }
                        else
                        {
                            try
                            {
                                cell.Value = FormatTwoDecimal(parsed);
                            }
                            catch { /* ignore formatting failure */ }
                        }
                    }
                }

                // 4) Evaluate Temperature checkbox -> if checked validate temperature accuracy column, else it must be blank
                if (colEvalTemp >= 0)
                {
                    bool evalTemp = GetCellBoolValue(rowIndex, colEvalTemp);

                    if (evalTemp)
                    {
                        if (colTempAccuracy >= 0)
                        {
                            var cAcc = row.Cells[colTempAccuracy];
                            var raw = cAcc?.Value?.ToString() ?? string.Empty;
                            if (string.IsNullOrWhiteSpace(raw))
                            {
                                string msg = $"Row {rowIndex + 1}: Temperature accuracy is required when Evaluate Temperature is checked.";
                                errors.Add(msg);
                                if (firstInvalidCell == null) firstInvalidCell = cAcc;
                                if (cAcc != null) cAcc.ErrorText = "Required";
                            }
                            else if (!TryParseTwoDecimal(raw, out double pacc))
                            {
                                string msg = $"Row {rowIndex + 1}: Temperature accuracy must be a number with at most 2 decimals.";
                                errors.Add(msg);
                                if (firstInvalidCell == null) firstInvalidCell = cAcc;
                                if (cAcc != null) cAcc.ErrorText = "Invalid format";
                            }
                            else
                            {
                                try { cAcc.Value = FormatTwoDecimal(pacc); } catch { }
                            }
                        }
                        else
                        {
                            // If evaluation requires temperature accuracy but no such column exists, mark as error
                            string msg = $"Row {rowIndex + 1}: Evaluate Temperature is checked but no Temperature Accuracy column is present.";
                            errors.Add(msg);
                            if (firstInvalidCell == null) firstInvalidCell = dataGridViewStep.Rows[rowIndex].Cells[Math.Max(0, colEvalTemp)];
                        }
                    }
                    else
                    {
                        // If eval unchecked, accuracy should be blank (if column exists)
                        if (colTempAccuracy >= 0)
                        {
                            var cAcc = row.Cells[colTempAccuracy];
                            if (cAcc?.Value != null && !string.IsNullOrWhiteSpace(cAcc.Value.ToString()))
                            {
                                string msg = $"Row {rowIndex + 1}: Temperature accuracy must be blank when Evaluate Temperature is not checked.";
                                errors.Add(msg);
                                if (firstInvalidCell == null) firstInvalidCell = cAcc;
                                if (cAcc != null) cAcc.ErrorText = "Must be blank";
                            }
                        }
                    }
                }

                // 5) Evaluate Humidity checkbox -> if checked validate humidity accuracy column, else it must be blank
                if (colEvalHum >= 0)
                {
                    bool evalHum = GetCellBoolValue(rowIndex, colEvalHum);

                    if (evalHum)
                    {
                        if (colHumAccuracy >= 0)
                        {
                            var cAcc = row.Cells[colHumAccuracy];
                            var raw = cAcc?.Value?.ToString() ?? string.Empty;
                            if (string.IsNullOrWhiteSpace(raw))
                            {
                                string msg = $"Row {rowIndex + 1}: Humidity accuracy is required when Evaluate Humidity is checked.";
                                errors.Add(msg);
                                if (firstInvalidCell == null) firstInvalidCell = cAcc;
                                if (cAcc != null) cAcc.ErrorText = "Required";
                            }
                            else if (!TryParseTwoDecimal(raw, out double pacc))
                            {
                                string msg = $"Row {rowIndex + 1}: Humidity accuracy must be a number with at most 2 decimals.";
                                errors.Add(msg);
                                if (firstInvalidCell == null) firstInvalidCell = cAcc;
                                if (cAcc != null) cAcc.ErrorText = "Invalid format";
                            }
                            else
                            {
                                try { cAcc.Value = FormatTwoDecimal(pacc); } catch { }
                            }
                        }
                        else
                        {
                            string msg = $"Row {rowIndex + 1}: Evaluate Humidity is checked but no Humidity Accuracy column is present.";
                            errors.Add(msg);
                            if (firstInvalidCell == null) firstInvalidCell = dataGridViewStep.Rows[rowIndex].Cells[Math.Max(0, colEvalHum)];
                        }
                    }
                    else
                    {
                        if (colHumAccuracy >= 0)
                        {
                            var cAcc = row.Cells[colHumAccuracy];
                            if (cAcc?.Value != null && !string.IsNullOrWhiteSpace(cAcc.Value.ToString()))
                            {
                                string msg = $"Row {rowIndex + 1}: Humidity accuracy must be blank when Evaluate Humidity is not checked.";
                                errors.Add(msg);
                                if (firstInvalidCell == null) firstInvalidCell = cAcc;
                                if (cAcc != null) cAcc.ErrorText = "Must be blank";
                            }
                        }
                    }
                }
            } // end rows loop

            if (errors.Count > 0)
            {
                try
                {
                    // Focus first invalid cell if available
                    if (firstInvalidCell != null)
                    {
                        dataGridViewStep.CurrentCell = firstInvalidCell;
                        dataGridViewStep.FirstDisplayedScrollingRowIndex = Math.Max(0, firstInvalidCell.RowIndex - 2);
                    }
                }
                catch { /* ignore focus errors */ }

                string msg = "Validation failed:\n" + string.Join("\n", errors.Distinct());
                MessageBox.Show(this, msg, "Validation Errors", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return false;
            }
            else
            {
                // Clear any lingering error texts
                foreach (DataGridViewRow row in dataGridViewStep.Rows)
                {
                    foreach (DataGridViewCell c in row.Cells)
                        c.ErrorText = string.Empty;
                }
                return true;
            }
        }

        private void ExportDataGridViewToXlsx(DataGridView grid, string filePath)
        {
            // Create the SpreadsheetDocument
            using (SpreadsheetDocument document = SpreadsheetDocument.Create(filePath, SpreadsheetDocumentType.Workbook))
            {
                // Add WorkbookPart
                WorkbookPart workbookPart = document.AddWorkbookPart();
                workbookPart.Workbook = new Workbook();

                // Add WorksheetPart
                WorksheetPart worksheetPart = workbookPart.AddNewPart<WorksheetPart>();
                SheetData sheetData = new SheetData();
                worksheetPart.Worksheet = new Worksheet(sheetData);

                // Create Sheets collection
                Sheets sheets = document.WorkbookPart.Workbook.AppendChild(new Sheets());
                Sheet sheet = new Sheet()
                {
                    Id = document.WorkbookPart.GetIdOfPart(worksheetPart),
                    SheetId = 1,
                    Name = "Steps"
                };
                sheets.Append(sheet);

                // Build header row from visible columns
                Row headerRow = new Row();
                List<int> visibleColumnIndexes = new List<int>();
                foreach (DataGridViewColumn col in grid.Columns)
                {
                    if (col.Visible)
                    {
                        visibleColumnIndexes.Add(col.Index);
                        string headerText = col.HeaderText ?? col.Name ?? string.Empty;
                        Cell headerCell = CreateTextCell(headerText);
                        headerRow.Append(headerCell);
                    }
                }
                sheetData.Append(headerRow);

                // Add data rows
                foreach (DataGridViewRow dgvRow in grid.Rows)
                {
                    if (dgvRow.IsNewRow) // skip the new row placeholder
                        continue;

                    Row newRow = new Row();
                    foreach (int colIndex in visibleColumnIndexes)
                    {
                        object val = dgvRow.Cells[colIndex].Value;
                        string text = val != null ? val.ToString() : string.Empty;
                        Cell dataCell = CreateTextCell(text);
                        newRow.Append(dataCell);
                    }
                    sheetData.Append(newRow);
                }

                workbookPart.Workbook.Save();
            }
        }

        private Cell CreateTextCell(string text)
        {
            // Create a cell with string data type
            return new Cell()
            {
                DataType = CellValues.String,
                CellValue = new CellValue(text ?? string.Empty)
            };
        }

        private void loadListToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var proceed = DataLossWarning();
            if (!proceed)
                return;

            // Determine application exe folder and ensure "Step Files" subfolder exists
            string exeFolder = Application.StartupPath;
            string stepFilesFolder = Path.Combine(exeFolder, "Step Files");
            try
            {
                if (!Directory.Exists(stepFilesFolder))
                    Directory.CreateDirectory(stepFilesFolder);
            }
            catch (Exception ex)
            {
                MessageBox.Show(this, "Unable to access folder for loading files: " + ex.Message, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            using (var dlg = new OpenFileDialog())
            {
                dlg.InitialDirectory = stepFilesFolder;
                dlg.Filter = "Excel Workbook|*.xlsx";
                dlg.DefaultExt = "xlsx";
                dlg.Title = "Load Steps from Excel Workbook";
                dlg.Multiselect = false;

                if (dlg.ShowDialog(this) != DialogResult.OK)
                    return;

                string filePath = dlg.FileName;
                try
                {
                    using (SpreadsheetDocument document = SpreadsheetDocument.Open(filePath, false))
                    {
                        WorkbookPart workbookPart = document.WorkbookPart;
                        if (workbookPart == null)
                        {
                            MessageBox.Show(this, "The selected file is not a valid Excel workbook.", "Invalid File", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                            return;
                        }

                        Sheet firstSheet = workbookPart.Workbook.Sheets.Elements<Sheet>().FirstOrDefault();
                        if (firstSheet == null)
                        {
                            MessageBox.Show(this, "The workbook contains no sheets.", "Invalid File", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                            return;
                        }

                        WorksheetPart worksheetPart = (WorksheetPart)workbookPart.GetPartById(firstSheet.Id);
                        SheetData sheetData = worksheetPart.Worksheet.GetFirstChild<SheetData>();
                        var rows = sheetData?.Elements<Row>().ToList() ?? new List<Row>();

                        if (rows.Count == 0)
                        {
                            MessageBox.Show(this, "The workbook contains no data to load.", "Empty File", MessageBoxButtons.OK, MessageBoxIcon.Information);
                            return;
                        }

                        // Local helper to read cell text, handling shared strings
                        string ReadCell(Cell cell)
                        {
                            if (cell == null)
                                return string.Empty;

                            string value = cell.InnerText;
                            if (cell.DataType != null && cell.DataType.Value == CellValues.SharedString)
                            {
                                if (int.TryParse(value, out int ssIndex))
                                {
                                    var sst = workbookPart.SharedStringTablePart?.SharedStringTable;
                                    if (sst != null)
                                    {
                                        var ssi = sst.Elements<SharedStringItem>().ElementAtOrDefault(ssIndex);
                                        if (ssi != null)
                                            return ssi.InnerText ?? string.Empty;
                                    }
                                }
                                return string.Empty;
                            }

                            // For booleans, numbers or inline strings just return the inner text
                            return value ?? string.Empty;
                        }

                        // Build list of visible column indexes and expected headers (order matters)
                        List<int> visibleColumnIndexes = new List<int>();
                        List<string> expectedHeaders = new List<string>();
                        foreach (DataGridViewColumn col in dataGridViewStep.Columns)
                        {
                            if (col.Visible)
                            {
                                visibleColumnIndexes.Add(col.Index);
                                string headerText = col.HeaderText ?? col.Name ?? string.Empty;
                                expectedHeaders.Add(headerText.Trim());
                            }
                        }

                        // Read header row (first row)
                        Row headerRow = rows[0];
                        var headerCells = headerRow.Elements<Cell>().ToList();
                        List<string> fileHeaders = headerCells.Select(c => ReadCell(c).Trim()).ToList();

                        // Validate header count matches visible columns
                        if (fileHeaders.Count != expectedHeaders.Count)
                        {
                            MessageBox.Show(this, "The Excel file format does not match the expected column layout (column count mismatch).", "Format Mismatch", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                            return;
                        }

                        // Validate header texts (case-insensitive, trimmed)
                        for (int i = 0; i < expectedHeaders.Count; i++)
                        {
                            string a = expectedHeaders[i] ?? string.Empty;
                            string b = fileHeaders[i] ?? string.Empty;
                            if (!string.Equals(a.Trim(), b.Trim(), StringComparison.OrdinalIgnoreCase))
                            {
                                MessageBox.Show(this, $"The Excel header \"{b}\" does not match the expected column \"{a}\".\nLoad aborted.", "Format Mismatch", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                                return;
                            }
                        }

                        // Validation passed - prepare to load rows
                        // If bound to a DataTable, get reference
                        DataTable targetTable = null;
                        if (dataGridViewStep.DataSource is DataTable dt)
                        {
                            targetTable = dt;
                        }
                        else if (dataGridViewStep.DataSource is BindingSource bs && bs.DataSource is DataTable bsTable)
                        {
                            targetTable = bsTable;
                        }

                        // If bound to DataTable, verify mapping from visible DataGridView columns to DataColumn exists
                        Dictionary<int, string> columnIndexToDataColumnName = new Dictionary<int, string>();
                        if (targetTable != null)
                        {
                            foreach (int colIndex in visibleColumnIndexes)
                            {
                                var dgvCol = dataGridViewStep.Columns[colIndex];
                                string tryName = dgvCol.Name ?? dgvCol.HeaderText ?? string.Empty;
                                if (targetTable.Columns.Contains(tryName))
                                {
                                    columnIndexToDataColumnName[colIndex] = tryName;
                                    continue;
                                }

                                // Try header text as column name
                                string header = dgvCol.HeaderText ?? string.Empty;
                                if (targetTable.Columns.Contains(header))
                                {
                                    columnIndexToDataColumnName[colIndex] = header;
                                    continue;
                                }

                                // No match found -> incompatible
                                MessageBox.Show(this, $"The DataTable bound to the grid does not contain a matching column for \"{dgvCol.HeaderText}\".\nLoad aborted.", "Format Mismatch", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                                return;
                            }
                        }

                        // Clear existing data
                        ClearData();

                        // Helper to parse bool-like strings
                        Func<string, bool> parseBool = s =>
                        {
                            if (string.IsNullOrWhiteSpace(s))
                                return false;
                            var t = s.Trim().ToLowerInvariant();
                            return t == "true" || t == "1" || t == "yes" || t == "y" || t == "x" || t == "checked";
                        };

                        // Load rows from Excel into the grid or DataTable
                        foreach (var dataRow in rows.Skip(1))
                        {
                            var cells = dataRow.Elements<Cell>().ToList();
                            // Build array of cell text values corresponding to expectedHeaders order
                            string[] values = new string[expectedHeaders.Count];
                            for (int i = 0; i < expectedHeaders.Count; i++)
                            {
                                // If the cell at position i exists, read it, otherwise empty string
                                if (i < cells.Count)
                                    values[i] = ReadCell(cells[i]);
                                else
                                    values[i] = string.Empty;
                            }

                            if (targetTable == null)
                            {
                                // Unbound grid: create an object[] matching visible columns and convert checkbox columns to bool
                                object[] rowValues = new object[visibleColumnIndexes.Count];
                                for (int idx = 0; idx < visibleColumnIndexes.Count; idx++)
                                {
                                    int dgvColIndex = visibleColumnIndexes[idx];
                                    var dgvCol = dataGridViewStep.Columns[dgvColIndex];

                                    string raw = values[idx] ?? string.Empty;

                                    if (dgvCol is DataGridViewCheckBoxColumn)
                                    {
                                        rowValues[idx] = parseBool(raw);
                                    }
                                    else
                                    {
                                        rowValues[idx] = raw;
                                    }
                                }

                                dataGridViewStep.Rows.Add(rowValues);
                            }
                            else
                            {
                                // Bound to DataTable: create DataRow and set mapped columns, respecting boolean DataColumns
                                DataRow newRow = targetTable.NewRow();
                                for (int idx = 0; idx < visibleColumnIndexes.Count; idx++)
                                {
                                    int dgvColIndex = visibleColumnIndexes[idx];
                                    string dataColName = columnIndexToDataColumnName[dgvColIndex];
                                    var dgvCol = dataGridViewStep.Columns[dgvColIndex];

                                    string raw = values[idx] ?? string.Empty;

                                    var targetCol = targetTable.Columns[dataColName];
                                    if (targetCol != null && targetCol.DataType == typeof(bool))
                                    {
                                        // assign parsed boolean (empty => false)
                                        newRow[dataColName] = parseBool(raw);
                                    }
                                    else
                                    {
                                        if (string.IsNullOrEmpty(raw))
                                            newRow[dataColName] = DBNull.Value;
                                        else
                                            newRow[dataColName] = raw;
                                    }
                                }
                                targetTable.Rows.Add(newRow);
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    MessageBox.Show(this, "Failed to load file: " + ex.Message, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }

        private bool GridHasData()
        {
            // Check DataSource scenarios first for an accurate count
            if (dataGridViewStep.DataSource is DataTable dt)
            {
                return dt.Rows.Count > 0;
            }

            if (dataGridViewStep.DataSource is BindingSource bs)
            {
                // If BindingSource wraps a DataTable, use its row count
                if (bs.DataSource is DataTable bsDt)
                    return bsDt.Rows.Count > 0;

                // BindingSource exposes Count; use it if available
                try
                {
                    if (bs.Count > 0)
                        return true;
                }
                catch
                {
                    // Swallow and fallback to row inspection
                }
            }

            // Fallback for unbound or other binding types:
            // Inspect rows ignoring the NewRow placeholder. Consider a row with any non-empty cell as data.
            foreach (DataGridViewRow row in dataGridViewStep.Rows)
            {
                if (row.IsNewRow)
                    continue;

                foreach (DataGridViewCell cell in row.Cells)
                {
                    var v = cell?.Value;
                    if (v != null && !string.IsNullOrWhiteSpace(v.ToString()))
                        return true;
                }
            }

            return false;
        }

        internal void validateToolStripMenuItem_Click(object sender, EventArgs e)
        {
            bool isValid = DataValidation();
            
            if (!isValid)
            {
                // Validation failed; do not proceed with calibration setup
                return;
            }
            if (!GridHasData())
            {
                MessageBox.Show(this, "No step file is loaded", "Validation", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }
            

            // Build list of StepClass objects from the grid and pass to CalibrationSetupFrm
            var steps = BuildStepListFromGrid();
            var calForm = new CalibrationSetupFrm(steps);
            calForm.Show(this);
        }

        // ----------------------------
        // Helper methods for new rules
        // ----------------------------
        private int FindColumnIndexByName(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
                return -1;

            for (int i = 0; i < dataGridViewStep.Columns.Count; i++)
            {
                var c = dataGridViewStep.Columns[i];
                string colName = (c?.Name ?? c?.HeaderText ?? string.Empty).Trim();
                if (string.Equals(colName, name.Trim(), StringComparison.OrdinalIgnoreCase))
                    return i;
            }
            return -1;
        }

        private int FindTemperatureAccuracyColumnIndex()
        {
            for (int i = 0; i < dataGridViewStep.Columns.Count; i++)
            {
                var c = dataGridViewStep.Columns[i];
                string combined = ((c?.Name ?? "") + "|" + (c?.HeaderText ?? "")).ToLowerInvariant();
                if (combined.Contains("accuracy") && (combined.Contains("temp") || combined.Contains("temperature")))
                    return i;
            }
            return -1;
        }

        private int FindHumidityAccuracyColumnIndex()
        {
            for (int i = 0; i < dataGridViewStep.Columns.Count; i++)
            {
                var c = dataGridViewStep.Columns[i];
                string combined = ((c?.Name ?? "") + "|" + (c?.HeaderText ?? "")).ToLowerInvariant();
                if (combined.Contains("accuracy") && (combined.Contains("hum") || combined.Contains("humidity")))
                    return i;
            }
            return -1;
        }

        private bool GetCellBoolValue(int rowIndex, int colIndex)
        {
            try
            {
                var r = dataGridViewStep.Rows[rowIndex];
                var cell = r.Cells[colIndex];
                if (cell == null)
                    return false;

                var val = cell.Value;
                if (val == null)
                    return false;

                if (val is bool b)
                    return b;

                // Sometimes CheckBox column can be boolean-like strings or ints
                string s = val.ToString();
                if (bool.TryParse(s, out bool parsedBool))
                    return parsedBool;
                if (int.TryParse(s, out int intVal))
                    return intVal != 0;

                return false;
            }
            catch
            {
                return false;
            }
        }

        private void ClearTempFields(int rowIndex)
        {
            int accIdx = FindTemperatureAccuracyColumnIndex();

            if (accIdx >= 0 && rowIndex >= 0 && rowIndex < dataGridViewStep.Rows.Count)
                dataGridViewStep.Rows[rowIndex].Cells[accIdx].Value = null;

            _hasUnsavedChanges = true;
        }

        private void ClearHumFields(int rowIndex)
        {
            int accIdx = FindHumidityAccuracyColumnIndex();

            if (accIdx >= 0 && rowIndex >= 0 && rowIndex < dataGridViewStep.Rows.Count)
                dataGridViewStep.Rows[rowIndex].Cells[accIdx].Value = null;

            _hasUnsavedChanges = true;
        }

        // Build List<StepClass> from the grid. Tries to be robust to column naming.
        private List<StepClass> BuildStepListFromGrid()
        {
            var result = new List<StepClass>();

            if (dataGridViewStep == null || dataGridViewStep.Columns.Count == 0)
                return result;

            // Helper to find column by tokens (name or header contains all tokens)
            int FindColumnIndexContaining(params string[] tokens)
            {
                if (tokens == null || tokens.Length == 0)
                    return -1;

                for (int i = 0; i < dataGridViewStep.Columns.Count; i++)
                {
                    var c = dataGridViewStep.Columns[i];
                    string combined = ((c?.Name ?? "") + "|" + (c?.HeaderText ?? "")).ToLowerInvariant();
                    bool all = true;
                    foreach (var t in tokens)
                    {
                        if (string.IsNullOrWhiteSpace(t))
                            continue;
                        if (!combined.Contains(t.ToLowerInvariant().Trim()))
                        {
                            all = false;
                            break;
                        }
                    }
                    if (all)
                        return i;
                }
                return -1;
            }

            // Identify columns (best-effort)
            int colStep = FindColumnIndexContaining("step");
            int colTempSet = FindColumnIndexContaining("temp", "set");
            int colHumSet = FindColumnIndexContaining("hum", "set");
            int colSoak = FindColumnIndexContaining("soak", "time");
            int colEvalTemp = FindColumnIndexContaining("eval", "temp");
            if (colEvalTemp < 0) colEvalTemp = FindColumnIndexContaining("evaluate", "temp");
            int colEvalHum = FindColumnIndexContaining("eval", "hum");
            if (colEvalHum < 0) colEvalHum = FindColumnIndexContaining("evaluate", "hum");

            int colTempAccuracy = FindTemperatureAccuracyColumnIndex();
            int colHumAccuracy = FindHumidityAccuracyColumnIndex();

            // Local helpers for parsing
            string GetCellText(DataGridViewRow row, int colIndex)
            {
                if (colIndex < 0 || colIndex >= dataGridViewStep.Columns.Count)
                    return string.Empty;
                var cell = row.Cells[colIndex];
                if (cell?.Value == null)
                    return string.Empty;
                return cell.Value.ToString().Trim();
            }

            double ParseDoubleOrNaN(string s)
            {
                if (string.IsNullOrWhiteSpace(s))
                    return double.NaN;

                string t = s.Trim().Replace(',', '.');
                if (double.TryParse(t, System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out double v))
                    return v;
                return double.NaN;
            }

            foreach (DataGridViewRow row in dataGridViewStep.Rows)
            {
                if (row == null || row.IsNewRow)
                    continue;

                var step = new StepClass();

                // Steps (string)
                if (colStep >= 0)
                    step.Steps = GetCellText(row, colStep);
                else
                    step.Steps = string.Empty;

                // Setpoints
                if (colHumSet >= 0)
                    step.HumiditySetPoint = ParseDoubleOrNaN(GetCellText(row, colHumSet));
                else
                    step.HumiditySetPoint = double.NaN;

                if (colTempSet >= 0)
                    step.TemperatureSetPoint = ParseDoubleOrNaN(GetCellText(row, colTempSet));
                else
                    step.TemperatureSetPoint = double.NaN;

                // Soak time (string)
                if (colSoak >= 0)
                    step.SoakTime = GetCellText(row, colSoak);
                else
                    step.SoakTime = string.Empty;

                // Evaluate flags
                if (colEvalTemp >= 0)
                    step.EvalTemp = GetCellBoolValue(row.Index, colEvalTemp);
                else
                    step.EvalTemp = false;

                if (colEvalHum >= 0)
                    step.EvalHumidity = GetCellBoolValue(row.Index, colEvalHum);
                else
                    step.EvalHumidity = false;

                // Accuracy values: map into StepClass numeric slots (MinTemperature/MinHumidity)
                // Min/Max were removed; use Min* fields to carry the single accuracy value, Max* set to NaN.
                step.MinTemperature = (colTempAccuracy >= 0) ? ParseDoubleOrNaN(GetCellText(row, colTempAccuracy)) : double.NaN;
                step.MaxTemperature = double.NaN;

                step.MinHumidity = (colHumAccuracy >= 0) ? ParseDoubleOrNaN(GetCellText(row, colHumAccuracy)) : double.NaN;
                step.MaxHumidity = double.NaN;

                result.Add(step);
            }

            return result;
        }

        private void buttonValidate_Click(object sender, EventArgs e)
        {
            validateToolStripMenuItem_Click(sender, e);
        }
    }
}
